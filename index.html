<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TU DUBLIN 2.0</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        .triangle {
            stroke: #000;
            stroke-width: 1;
            fill: none;
        }

        .user-point {
            fill: #f00;
            stroke: #000;
            stroke-width: 1;
        }
    </style>
</head>
<body>

<div>
    <label for="activeSlider">Active (%): </label>
    <input type="range" id="activeSlider" name="active" class="slider" min="0" max="100" value="33">
    <span id="activeValue">33</span>%
</div>
<div>
    <label for="publicTransportSlider">Public Transport (%): </label>
    <input type="range" id="publicTransportSlider" name="publicTransport" class="slider" min="0" max="100" value="33">
    <span id="publicTransportValue">33</span>%
</div>
<div>
    <label for="privateCarsSlider">Private Cars (%): </label>
    <input type="range" id="privateCarsSlider" name="privateCars" class="slider" min="0" max="100" value="34">
    <span id="privateCarsValue">34</span>%
</div>
    
<button id="toggleCities">Toggle Cities</button>
<div id="tooltip" style="position: absolute; visibility: hidden; background-color: white; border: 1px solid black; padding: 5px;"></div>

<div id="trianglePlot"></div>

<script>
    const width = 600, height = 600;
    const margin = { top: 30, right: 30, bottom: 30, left: 30 };

    const svg = d3.select('#trianglePlot').append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Define the points of the triangle
    const scale = 0.6;
    const points = [
        [(1 - scale) * width / 2, scale * height], // bottom-left
        [width / 2, (1 - scale) * height / 2], // top-center
        [scale * width + (1 - scale) * width / 2, scale * height] // bottom-right
    ];
    
    // Draw the triangle
    svg.append('path')
        .attr('class', 'triangle')
        .attr('d', `M ${points.join('L ')} Z`);

    // Initial position of the user point
    const initialPoint = calculatePointPosition({ active: 33, publicTransport: 33, privateCars: 34 });

    // Add a black circle as the background for the image
    const imageSize = 20; // Size of the image
    svg.append('circle')
        .attr('class', 'user-point-background')
        .attr('cx', initialPoint.x)
        .attr('cy', initialPoint.y)
        .attr('r', imageSize / 2) // The radius to cover the image size
        .attr('fill', 'black');

    // User point element
    const userPoint = svg.append('image')
        .attr('href', 'you.png') // Path to your image
        .attr('width', imageSize) // Width of the image
        .attr('height', imageSize) // Height of the image
        .attr('x', initialPoint.x - (imageSize / 2)) // Center the image on the point
        .attr('y', initialPoint.y - (imageSize / 2));

    // Icon and background sizes
    const iconSize = 20; // Size of the icons
    const backgroundSize = 25; // Size of the background circles

    function addIconWithBackground(position, iconFile, backgroundColor) {
        // Add the background circle
        svg.append('circle')
            .attr('cx', position.x)
            .attr('cy', position.y)
            .attr('r', backgroundSize / 2)
            .attr('fill', backgroundColor);
    
        // Add the icon image on top of the background circle
        svg.append('image')
            .attr('href', iconFile)
            .attr('width', iconSize)
            .attr('height', iconSize)
            .attr('x', position.x - iconSize / 2)
            .attr('y', position.y - iconSize / 2);
    }

    // Add icons with backgrounds
    addIconWithBackground(activePosition, 'a.png', 'yellow');
    addIconWithBackground(publicTransportPosition, 'b.png', 'lightblue');
    addIconWithBackground(privateCarsPosition, 'c.png', 'lightcoral'); // using 'lightcoral' as a light red color
    


    // Function to calculate point position based on slider values
    function calculatePointPosition(data) {
        // Calculate the normalized percentages
        const activeNormalized = data.active / 100;
        const publicTransportNormalized = data.publicTransport / 100;
        const privateCarsNormalized = data.privateCars / 100;
    
        // Calculate the position of the point using barycentric coordinates
        // For the SVG, the origin is at the top-left corner, so we need to adjust the y-coordinate calculation
        const x = (points[0][0] * publicTransportNormalized) +
                  (points[1][0] * activeNormalized) +
                  (points[2][0] * privateCarsNormalized);
    
        // Since the y-coordinate increases as you go down the SVG, we subtract from the total height
        const y = height - (
            (height - points[0][1]) * publicTransportNormalized +
            (height - points[1][1]) * activeNormalized +
            (height - points[2][1]) * privateCarsNormalized
        );
    
        return { x: x, y: y };
    }


    // Update function for sliders
    function updatePosition() {
        // Adjust the other two sliders to make sure the total is 100
        const active = parseFloat(d3.select('#activeSlider').property('value'));
        const publicTransport = parseFloat(d3.select('#publicTransportSlider').property('value'));
        const privateCars = parseFloat(d3.select('#privateCarsSlider').property('value'));
        const total = active + publicTransport + privateCars;
        
        // The slider that triggered the event keeps its value
        // The other two sliders adjust proportionally to fill the remaining percentage
        const adjustedPublicTransport = 100 * publicTransport / total;
        const adjustedPrivateCars = 100 * privateCars / total;
        const adjustedActive = 100 * active / total;
    
        // Update the actual sliders' positions
        d3.select('#activeSlider').property('value', adjustedActive);
        d3.select('#publicTransportSlider').property('value', adjustedPublicTransport);
        d3.select('#privateCarsSlider').property('value', adjustedPrivateCars);
    
        const data = {
            active: adjustedActive,
            publicTransport: adjustedPublicTransport,
            privateCars: adjustedPrivateCars
        };
    
        const pointPosition = calculatePointPosition(data);
        svg.select('.user-point-background') // Select the background circle and update its position
            .attr('cx', pointPosition.x)
            .attr('cy', pointPosition.y);

        userPoint
            .attr('x', pointPosition.x - (imageSize / 2)) // Center the image on the new point
            .attr('y', pointPosition.y - (imageSize / 2));
        
        // Update slider values displayed to the user
        d3.select('#activeValue').text(adjustedActive.toFixed(0));
        d3.select('#publicTransportValue').text(adjustedPublicTransport.toFixed(0));
        d3.select('#privateCarsValue').text(adjustedPrivateCars.toFixed(0));
    }

    // Adjusts the values of the other two sliders whenever one changes, to maintain the total at 100%
    function adjustSliderValues(changedSlider) {
        // Find out which sliders need to be adjusted
        const sliders = ['active', 'publicTransport', 'privateCars'];
        const unchangedSliders = sliders.filter(s => s !== changedSlider);
    
        // Get the current total percentage
        let total = sliders.reduce((acc, s) => acc + parseFloat(d3.select('#' + s + 'Slider').property('value')), 0);
    
        // Calculate the amount to adjust the other two sliders by
        let adjustAmount = (100 - parseFloat(d3.select('#' + changedSlider + 'Slider').property('value'))) / unchangedSliders.length;
    
        // Adjust the other two sliders
        unchangedSliders.forEach(s => {
            let currentValue = parseFloat(d3.select('#' + s + 'Slider').property('value'));
            let newValue = total > 100 ? currentValue - (total - 100) / 2 : adjustAmount;
            d3.select('#' + s + 'Slider').property('value', newValue);
            d3.select('#' + s + 'Value').text(newValue.toFixed(0));
        });
    }


    // Function to show tooltip
    function showTooltip(city, coords) {
        const tooltip = d3.select('#tooltip');
        tooltip.style('visibility', 'visible')
               .style('top', (coords.y + 'px'))
               .style('left', (coords.x + 'px'))
               .html('City: ' + city.City + '<br>' +
                     'Active: ' + city.Active + '<br>' +
                     'Public Transport: ' + city.PublicTransport + '<br>' +
                     'Private Cars: ' + city.PrivateCars);
    }
    
    // Function to hide tooltip
    function hideTooltip() {
        const tooltip = d3.select('#tooltip');
        tooltip.style('visibility', 'hidden');
    }

    let citiesDisplayed = false;
    // Add a button toggle event listener
    d3.select('#toggleCities').on('click', function() {
        citiesDisplayed = !citiesDisplayed;
        svg.selectAll('.city-circle').style('visibility', citiesDisplayed ? 'visible' : 'hidden');
    });

    // Function to initialize the chart with city data
    function init() {
        // Load the CSV data
        d3.csv("ModalShare.csv").then(function(cities) {
            // For each city, calculate its position and add a circle to the SVG
            cities.forEach(function(city) {
                const point = calculatePointPosition({
                    active: +city.Active,       // Corresponds to the 'Active' column
                    publicTransport: +city.Bus, // Corresponds to the 'Bus' column
                    privateCars: +city.Car      // Corresponds to the 'Car' column
                });
    
                // Add the circle for each city
                svg.append('circle')
                    .attr('class', 'city-circle')
                    .attr('cx', point.x)
                    .attr('cy', point.y)
                    .attr('r', 5) // Adjust radius based on city size if needed
                    .attr('fill', 'gray') // Customize as needed
                    .attr('stroke', 'black')
                    .style('visibility', 'hidden') // Start with cities hidden
                    .on('mouseover', function(d) {
                        d3.select(this).attr('fill', 'orange'); // Highlight
                        showTooltip(city, { x: d3.event.pageX, y: d3.event.pageY });
                    })
                    .on('mouseout', function(d) {
                        d3.select(this).attr('fill', 'gray'); // Remove highlight
                        hideTooltip();
                    });
            });
        }).catch(function(error) {
            console.error("Error loading or processing the CSV file:", error);
        });
    }


    

    // Attach event listeners to sliders
    d3.selectAll('.slider').on('input', function() {
        let changedSlider = this.name; // Get the name of the slider that was changed
        adjustSliderValues(changedSlider); // Adjust the other two sliders
    
        // After adjustment, re-fetch the values and update the position
        const data = {
            active: parseFloat(d3.select('#activeSlider').property('value')),
            publicTransport: parseFloat(d3.select('#publicTransportSlider').property('value')),
            privateCars: parseFloat(d3.select('#privateCarsSlider').property('value'))
        };
    
        // Update the position of the "You" circle
        const pointPosition = calculatePointPosition(data);
        userPoint
            .attr('cx', pointPosition.x)
            .attr('cy', pointPosition.y);
    
        // Update displayed slider values
        d3.select('#activeValue').text(data.active.toFixed(0));
        d3.select('#publicTransportValue').text(data.publicTransport.toFixed(0));
        d3.select('#privateCarsValue').text(data.privateCars.toFixed(0));
    });


    // Initialize sliders with the event listener
    d3.selectAll('.slider').on('input', updatePosition);

    // Initial update for the position
    updatePosition();

    // Call init to start the visualization
    init();

</script>
</body>
</html>
