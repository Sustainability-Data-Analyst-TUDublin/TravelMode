<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TU DUBLIN 0.6</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        .triangle {
            stroke: #000;
            stroke-width: 1;
            fill: none;
        }

        .user-point {
            fill: #f00;
            stroke: #000;
            stroke-width: 1;
        }
    </style>
</head>
<body>

<div>
    <label for="walkingSlider">Walking (%): </label>
    <input type="range" id="walkingSlider" name="walking" class="slider" min="0" max="100" value="33">
    <span id="walkingValue">33</span>%
</div>
<div>
    <label for="publicTransportSlider">Public Transport (%): </label>
    <input type="range" id="publicTransportSlider" name="publicTransport" class="slider" min="0" max="100" value="33">
    <span id="publicTransportValue">33</span>%
</div>
<div>
    <label for="privateCarsSlider">Private Cars (%): </label>
    <input type="range" id="privateCarsSlider" name="privateCars" class="slider" min="0" max="100" value="34">
    <span id="privateCarsValue">34</span>%
</div>

<div id="trianglePlot"></div>

<script>
    const width = 600, height = 600;
    const margin = { top: 30, right: 30, bottom: 30, left: 30 };

    const svg = d3.select('#trianglePlot').append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Define the points of the triangle
    const scale = 0.6;
    const points = [
        [width * 0.5 * (1 - scale), height * scale], // bottom-left
        [width / 2, height * (1 - scale)], // top-center
        [width - width * 0.5 * (1 - scale), height * scale] // bottom-right
    ];
    
    // Draw the triangle
    svg.append('path')
        .attr('class', 'triangle')
        .attr('d', `M ${points.join('L ')} Z`);

    // Initial position of the user point
    const initialPoint = calculatePointPosition({ walking: 33, publicTransport: 33, privateCars: 34 });

    // User point element
    const userPoint = svg.append('circle')
        .attr('class', 'user-point')
        .attr('r', 5)
        .attr('cx', initialPoint.x)
        .attr('cy', initialPoint.y);

    // Function to calculate point position based on slider values
    function calculatePointPosition(data) {
        // Map the percentages to a point in the triangle using barycentric coordinates
        const walkingFactor = data.walking / 100;
        const publicTransportFactor = data.publicTransport / 100;
        const privateCarsFactor = data.privateCars / 100;

        // Calculate the position of the point within the scaled triangle
        const x = (points[2][0] * privateCarsFactor) + 
                  (points[1][0] * publicTransportFactor) + 
                  (points[0][0] * walkingFactor);
        const y = height - ((height - points[0][1]) * (privateCarsFactor + publicTransportFactor));

        return { x, y };
    }


    // Update function for sliders
    function updatePosition() {
        // Adjust the other two sliders to make sure the total is 100
        const walking = parseFloat(d3.select('#walkingSlider').property('value'));
        const publicTransport = parseFloat(d3.select('#publicTransportSlider').property('value'));
        const privateCars = parseFloat(d3.select('#privateCarsSlider').property('value'));
        const total = walking + publicTransport + privateCars;
        
        // The slider that triggered the event keeps its value
        // The other two sliders adjust proportionally to fill the remaining percentage
        const adjustedPublicTransport = 100 * publicTransport / total;
        const adjustedPrivateCars = 100 * privateCars / total;
        const adjustedWalking = 100 * walking / total;
    
        // Update the actual sliders' positions
        d3.select('#walkingSlider').property('value', adjustedWalking);
        d3.select('#publicTransportSlider').property('value', adjustedPublicTransport);
        d3.select('#privateCarsSlider').property('value', adjustedPrivateCars);
    
        const data = {
            walking: adjustedWalking,
            publicTransport: adjustedPublicTransport,
            privateCars: adjustedPrivateCars
        };
    
        const pointPosition = calculatePointPosition(data);
        userPoint
            .attr('cx', pointPosition.x)
            .attr('cy', pointPosition.y);
    
        // Update slider values displayed to the user
        d3.select('#walkingValue').text(adjustedWalking.toFixed(0));
        d3.select('#publicTransportValue').text(adjustedPublicTransport.toFixed(0));
        d3.select('#privateCarsValue').text(adjustedPrivateCars.toFixed(0));
    }

    // Adjusts the values of the other two sliders whenever one changes, to maintain the total at 100%
    function adjustSliderValues(changedSlider) {
        // Find out which sliders need to be adjusted
        const sliders = ['walking', 'publicTransport', 'privateCars'];
        const otherSliders = sliders.filter(s => s !== changedSlider);
    
        // Get the current value of the changed slider
        const changedValue = parseFloat(d3.select('#' + changedSlider + 'Slider').property('value'));
    
        // Calculate the amount left for the other two sliders
        const remaining = 100 - changedValue;
    
        // Distribute the remaining amount between the other two sliders
        const otherValues = otherSliders.map(slider => parseFloat(d3.select('#' + slider + 'Slider').property('value')));
        const otherTotal = otherValues.reduce((sum, value) => sum + value, 0);
        
        otherSliders.forEach(slider => {
            let newValue;
            if (otherTotal === 0) {
                newValue = remaining / otherSliders.length;
            } else {
                newValue = remaining * (parseFloat(d3.select('#' + slider + 'Slider').property('value')) / otherTotal);
            }
            d3.select('#' + slider + 'Slider').property('value', newValue);
            d3.select('#' + slider + 'Value').text(newValue.toFixed(0));
        });
    }


    // Attach event listeners to sliders
    d3.selectAll('.slider').on('input', function() {
        let changedSlider = this.name; // Get the name of the slider that was changed
        adjustSliderValues(changedSlider); // Adjust the other two sliders
    
        // After adjustment, re-fetch the values and update the position
        const data = {
            walking: parseFloat(d3.select('#walkingSlider').property('value')),
            publicTransport: parseFloat(d3.select('#publicTransportSlider').property('value')),
            privateCars: parseFloat(d3.select('#privateCarsSlider').property('value'))
        };
        
        // Update the position of the "You" circle
        const pointPosition = calculatePointPosition(data);
        userPoint
            .attr('cx', pointPosition.x)
            .attr('cy', pointPosition.y);
    
        // Update displayed slider values
        d3.select('#walkingValue').text(data.walking.toFixed(0));
        d3.select('#publicTransportValue').text(data.publicTransport.toFixed(0));
        d3.select('#privateCarsValue').text(data.privateCars.toFixed(0));
    
        // Ensure that we don't draw the point if the total isn't exactly 100
        if (data.walking + data.publicTransport + data.privateCars === 100) {
            userPoint.attr('cx', pointPosition.x).attr('cy', pointPosition.y);
        }
    }

   // Initialize sliders with the event listener
    d3.selectAll('.slider').on('input', updatePosition);

    // Initial update for the position
    updatePosition();

</script>
</body>
</html>

       
